/// Default number of variables / function defined in the global scope
///  - Is fixed at this level in the C++14 bootstrapping environment
int default_num_globals = 256;

/// Default number of characters to be reserved for function name mangling
///  - Is fixed at this level in the C++14 bootstrapping environment
int default_mangle_length = 256;

/// Default number of function parameters
///  - Is fixed at this level in the C++14 botstrapping environment
int default_function_parameters = 16;

int PROPERTY_FUNCTION = 1;
int PROPERTY_OBJECT = 2;
int PROPERTY_ARRAY = 4;


/// Returns true if a specific token is a primitive type
bool is_primitive_type(TokenType varType)
{
	if (	varType == TOKEN_U8  || varType == TOKEN_S8  || 
		varType == TOKEN_U16 || varType == TOKEN_S16 ||
		varType == TOKEN_U32 || varType == TOKEN_S32 ||
		varType == TOKEN_INT || varType == TOKEN_BOOL || varType == TOKEN_VOID )
	{
		return true;
	}
	return false;
}

/// Returns an appropriate string representation of a variable type
String var_type_string(int varType)
{
	if (varType==TOKEN_U8) return String("U8");
	else if (varType==TOKEN_S8) return String("S8");
	else if (varType==TOKEN_U16) return String("U16");
	else if (varType==TOKEN_S16) return String("S16");
	else if (varType==TOKEN_U32) return String("U32");
	else if (varType==TOKEN_S32) return String("S32");
	else if (varType==TOKEN_INT) return String("INT");
	else if (varType==TOKEN_VOID) return String("VOID");
	else if (varType==TOKEN_BOOL) return String("BOOL");
	return String("UNK");
}

class Syntaxer
{
protected:
	bool _open = false;
	bool _error = false;
	TokenStream Stream;
	String _filename;

	//Used kinda as a lookahaed
	Token currentTok;


	int 		global_nxtid = 0;
	int array 	global_types;
	String array	global_typenames; // Used if the type is SYNTAXER_OBJECT
	s32 array	global_data;
	String array 	global_names;
	int array	global_properties;

	


	/// Prints a pretty warning message
	void print_warning(String warning_string, u32 warnlinenum)
	{
		std_out.putstring(String("[SYNTAX] "));
		std_out.putstring(_filename);
		std_out.putchar(':');
		std_out.putint(warnlinenum);
		std_out.putstring(" - Warning: ");
		std_out.putstring(warning_string);
		std_out.putchar('\n');
	}

	/// Prints a pretty error message
	void print_error(String error_string, u32 errorlinenum)
	{
		std_out.putstring(String("[SYNTAX] "));
		std_out.putstring(_filename);
		std_out.putchar(':');
		std_out.putint(errorlinenum);
		std_out.putstring(" - Error: ");
		std_out.putstring(error_string);
		std_out.putchar('\n');
		_error = true;
	}

	void parse_global_function()
	{
		global_properties[global_nxtid] |= PROPERTY_FUNCTION;
		String function_mangle(default_mangle_length);
		bool parse_function = true;

		while (parse_function && !_error)
		{
			currentTok = Stream.getToken();
			if (currentTok.type == TOKEN_CBRACKET)
				parse_function = false;
			else if (currentTok.type == TOKEN_ENDOFSTREAM)
				print_error(String("End-of-stream encountered while parsing function parameters"),currentTok.linenum);
		}
	}

	void parse_global_variable()
	{
		Token nxtTok = Stream.getToken();
		if (nxtTok.type == TOKEN_NAME)
		{
			if (nxtTok.str.compare(String("array")))
			{
				nxtTok = Stream.getToken();
				global_properties[global_nxtid] |= PROPERTY_ARRAY;
			}			


			String var_name = nxtTok.str;
			global_types[global_nxtid] = currentTok.type;
			global_typenames[global_nxtid] = currentTok.str;
			global_names[global_nxtid] = var_name;

			nxtTok = Stream.getToken();
			if (nxtTok.type == TOKEN_ASSIGN)
			{

				nxtTok = Stream.getToken();
				if (nxtTok.type == TOKEN_INT_LIT)
					global_data[global_nxtid] = nxtTok.value;
				else if (nxtTok.type == TOKEN_BOOL_TRUE)
					global_data[global_nxtid] = 1;
				else if (nxtTok.type == TOKEN_BOOL_FALSE)
					global_data[global_nxtid] = 0;
				else
					print_error(String("Expected integer literal"),nxtTok.linenum);

				nxtTok = Stream.getToken();
			}
			else if (nxtTok.type == TOKEN_OBRACKET)
			{
				parse_global_function();
			}
			else if (nxtTok.type != TOKEN_SEMICOLON)
				print_error(String("Expected semicolon"),nxtTok.linenum);
			global_nxtid += 1;
		}
		else
			print_error(String("Invalid name for variable / function"),nxtTok.linenum);
	}

public:
	/// Opens a file and prepares it for the tokenizer and syntaxer
	bool open(String filename)
	{
		if (!Stream.open(filename))
			return false;
		_open = true;
		_error = false;
		_filename = filename;

		global_nxtid = 0;
		global_types.reset(default_num_globals);
		global_typenames.reset(default_num_globals);
		global_names.reset(default_num_globals);
		global_data.reset(default_num_globals);
		global_properties.reset(default_num_globals);
		return true;
	}

	/// Parses a file, printing information about it.
	//@ return false on failure
	bool parse()
	{

		bool _eof = false;
		while (!_error && !_eof)
		{
			currentTok = Stream.getToken();

			// Start a global primitive type definition
			if (is_primitive_type(currentTok.type))
			{
				parse_global_variable();
			}
			else if (currentTok.type == TOKEN_NAME)
			{
				global_properties[global_nxtid] |= PROPERTY_OBJECT;
				parse_global_variable();
			}
			else if (currentTok.type == TOKEN_ERROR) _error = true;
			else if (currentTok.type == TOKEN_ENDOFSTREAM) _eof = true;
		}
		return !_error;
	}
	
	
	void printGlobals()
	{
		std_out.putstring("--------GLOBALS--------\n\n");
		std_out.putstring("PROPERTIES\t TYPE \tOBJNAME\tVALUE\t NAME \t\n");
		std_out.putstring("----------\t------\t-------\t-----\t------\t\n");
		for (int i = 0; i < global_nxtid; ++i)
		{
			std_out.putint(global_properties[i]);
			std_out.putstring(String("\t\t"));
			if ((global_properties[i]&PROPERTY_OBJECT)==0)
				std_out.putstring(var_type_string(global_types[i]));
			else
				std_out.putstring(String("OBJ"));
			std_out.putchar('\t');
			std_out.putstring(global_typenames[i]);
			std_out.putchar('\t');
			std_out.putint(global_data[i]);
			std_out.putchar('\t');
			std_out.putstring(global_names[i]);
			std_out.putchar('\n');
		}
		std_out.putstring("\n-----------------------\n");
	}
  
};

