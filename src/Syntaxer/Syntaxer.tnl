/// Default number of variables / function defined in the global scope
///  - Is fixed at this level in the C++14 bootstrapping environment
int default_num_globals = 256;

/// Default number of characters to be reserved for function name mangling
///  - Is fixed at this level in the C++14 bootstrapping environment
int default_mangle_length = 256;

/// Default number of function parameters
///  - Is fixed at this level in the C++14 botstrapping environment
int default_function_arguments = 16;

/// Default character to mangle function names with
s32 mangle_character = '-';

int PROPERTY_FUNCTION = 1;
int PROPERTY_OBJECT = 2;
int PROPERTY_ARRAY = 4;


/// Returns true if a specific token is a primitive type
bool is_primitive_type(TokenType varType)
{
	if (	varType == TOKEN_U8  || varType == TOKEN_S8  || 
		varType == TOKEN_U16 || varType == TOKEN_S16 ||
		varType == TOKEN_U32 || varType == TOKEN_S32 ||
		varType == TOKEN_INT || varType == TOKEN_BOOL || varType == TOKEN_VOID )
	{
		return true;
	}
	return false;
}

/// Returns an appropriate string representation of a variable type
String var_type_string(int varType)
{
	if (varType==TOKEN_U8) return String("U8");
	else if (varType==TOKEN_S8) return String("S8");
	else if (varType==TOKEN_U16) return String("U16");
	else if (varType==TOKEN_S16) return String("S16");
	else if (varType==TOKEN_U32) return String("U32");
	else if (varType==TOKEN_S32) return String("S32");
	else if (varType==TOKEN_INT) return String("INT");
	else if (varType==TOKEN_VOID) return String("VOID");
	else if (varType==TOKEN_BOOL) return String("BOOL");
	return String("UNK");
}

class Syntaxer
{
protected:
	bool _open = false;
	bool _error = false;
	TokenStream Stream;
	String _filename;

	//Used kinda as a lookahaed
	Token currentTok;


	int global_nxtid = 0;
	Variable array globals;

	/// Prints a pretty warning message
	void print_warning(String warning_string, u32 warnlinenum)
	{
		std_out.putstring(String("[SYNTAX] "));
		std_out.putstring(_filename);
		std_out.putchar(':');
		std_out.putint(warnlinenum);
		std_out.putstring(" - Warning: ");
		std_out.putstring(warning_string);
		std_out.putchar('\n');
	}

	/// Prints a pretty error message
	void print_error(String error_string, u32 errorlinenum)
	{
		std_out.putstring(String("[SYNTAX] "));
		std_out.putstring(_filename);
		std_out.putchar(':');
		std_out.putint(errorlinenum);
		std_out.putstring(" - Error: ");
		std_out.putstring(error_string);
		std_out.putchar('\n');
		_error = true;
	}

	void parse_global_function()
	{
		globals[global_nxtid].properties |= PROPERTY_FUNCTION;
		String functionMangle(default_mangle_length);
		bool parseFunction = true;

		Variable array functionArguments;
		functionArguments.reset(default_function_arguments);
		int functionArgumentID = 0;

		while (parseFunction && !_error)
		{
			currentTok = Stream.getToken();
			if (currentTok.type == TOKEN_CBRACKET)
				parseFunction = false;
			else if (currentTok.type == TOKEN_ENDOFSTREAM)
				print_error(String("End-of-stream encountered while parsing function parameters"),currentTok.linenum);
			else if (is_primitive_type(currentTok.type))
			{
				functionArguments[functionArgumentID].type = currentTok.type;
				Token nxtTok = Stream.getToken();
				if (nxtTok.type != TOKEN_NAME)
					print_error(String("Expected argument name after type in argument list"),nxtTok.linenum);
				else
				{
					functionArguments[functionArgumentID].name = nxtTok.str;
					nxtTok = Stream.getToken();
					if (nxtTok.type == TOKEN_CBRACKET)
						parseFunction = false;
					else if (nxtTok.type != TOKEN_COMMA)
						print_error(String("Expected ',' or ')' after argument declaration in argument list"), nxtTok.linenum);
				}				
				functionArgumentID+=1;
			}
		}

		if (!_error)
		{
			for (int i = 0; i < functionArgumentID; ++i)
			{
				functionMangle.append(mangle_character);
				functionMangle.concat(var_type_string(functionArguments[i].type));
			}
			int newNameLength = globals[global_nxtid].name.length() + functionMangle.length();
			String newName(newNameLength);
			newName.concat(globals[global_nxtid].name);
			newName.concat(functionMangle);
			globals[global_nxtid].name = newName;
		}
	}

	void parse_global_variable()
	{
		Token nxtTok = Stream.getToken();
		if (nxtTok.type == TOKEN_NAME)
		{
			if (nxtTok.str.compare(String("array")))
			{
				nxtTok = Stream.getToken();
				globals[global_nxtid].properties |= PROPERTY_ARRAY;
			}			


			String var_name = nxtTok.str;
			globals[global_nxtid].type = currentTok.type;
			globals[global_nxtid].objname = currentTok.str;
			globals[global_nxtid].name = var_name;

			nxtTok = Stream.getToken();
			if (nxtTok.type == TOKEN_ASSIGN)
			{

				nxtTok = Stream.getToken();
				if (nxtTok.type == TOKEN_INT_LIT)
					globals[global_nxtid].default_value = nxtTok.value;
				else if (nxtTok.type == TOKEN_BOOL_TRUE)
					globals[global_nxtid].default_value = 1;
				else if (nxtTok.type == TOKEN_BOOL_FALSE)
					globals[global_nxtid].default_value = 0;
				else
					print_error(String("Expected integer literal"),nxtTok.linenum);

				nxtTok = Stream.getToken();
			}
			else if (nxtTok.type == TOKEN_OBRACKET)
			{
				parse_global_function();
			}
			else if (nxtTok.type != TOKEN_SEMICOLON)
				print_error(String("Expected semicolon"),nxtTok.linenum);
			global_nxtid += 1;
		}
		else
			print_error(String("Invalid name for variable / function"),nxtTok.linenum);
	}

public:
	/// Opens a file and prepares it for the tokenizer and syntaxer
	bool open(String filename)
	{
		if (!Stream.open(filename))
			return false;
		_open = true;
		_error = false;
		_filename = filename;

		global_nxtid = 0;
		globals.reset(default_num_globals);

		return true;
	}

	/// Parses a file, printing information about it.
	//@ return false on failure
	bool parse()
	{

		bool _eof = false;
		while (!_error && !_eof)
		{
			currentTok = Stream.getToken();

			// Start a global primitive type definition
			if (is_primitive_type(currentTok.type))
			{
				parse_global_variable();
			}
			else if (currentTok.type == TOKEN_NAME)
			{
				globals[global_nxtid].properties |= PROPERTY_OBJECT;
				parse_global_variable();
			}
			else if (currentTok.type == TOKEN_ERROR) _error = true;
			else if (currentTok.type == TOKEN_ENDOFSTREAM) _eof = true;
		}
		return !_error;
	}
	
	
	void printGlobals()
	{
		std_out.putstring("--------GLOBALS--------\n\n");
		std_out.putstring("PROPERTIES\t TYPE \tOBJNAME\tVALUE\t NAME \t\n");
		std_out.putstring("----------\t------\t-------\t-----\t------\t\n");
		for (int i = 0; i < global_nxtid; ++i)
		{
			std_out.putint(globals[i].properties);
			std_out.putstring(String("\t\t"));
			if ((globals[i].properties&PROPERTY_OBJECT)==0)
				std_out.putstring(var_type_string(globals[i].type));
			else
				std_out.putstring(String("OBJ"));
			std_out.putchar('\t');
			std_out.putstring(globals[i].objname);
			std_out.putchar('\t');
			std_out.putint(globals[i].default_value);
			std_out.putchar('\t');
			std_out.putstring(globals[i].name);
			std_out.putchar('\n');
		}
		std_out.putstring("\n-----------------------\n");
	}
  
};

